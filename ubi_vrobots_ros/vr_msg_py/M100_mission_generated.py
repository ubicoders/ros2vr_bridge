# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Vec3Msg(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Vec3Msg()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsVec3Msg(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def Vec3MsgBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x31\x30\x30", size_prefixed=size_prefixed)

    # Vec3Msg
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Vec3Msg
    def X(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Vec3Msg
    def Y(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Vec3Msg
    def Z(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def Vec3MsgStart(builder):
    builder.StartObject(3)

def Vec3MsgAddX(builder, x):
    builder.PrependFloat32Slot(0, x, 0.0)

def Vec3MsgAddY(builder, y):
    builder.PrependFloat32Slot(1, y, 0.0)

def Vec3MsgAddZ(builder, z):
    builder.PrependFloat32Slot(2, z, 0.0)

def Vec3MsgEnd(builder):
    return builder.EndObject()



class Vec3MsgT(object):

    # Vec3MsgT
    def __init__(self):
        self.x = 0.0  # type: float
        self.y = 0.0  # type: float
        self.z = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        vec3Msg = Vec3Msg()
        vec3Msg.Init(buf, pos)
        return cls.InitFromObj(vec3Msg)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, vec3Msg):
        x = Vec3MsgT()
        x._UnPack(vec3Msg)
        return x

    # Vec3MsgT
    def _UnPack(self, vec3Msg):
        if vec3Msg is None:
            return
        self.x = vec3Msg.X()
        self.y = vec3Msg.Y()
        self.z = vec3Msg.Z()

    # Vec3MsgT
    def Pack(self, builder):
        Vec3MsgStart(builder)
        Vec3MsgAddX(builder, self.x)
        Vec3MsgAddY(builder, self.y)
        Vec3MsgAddZ(builder, self.z)
        vec3Msg = Vec3MsgEnd(builder)
        return vec3Msg


class Vec4Msg(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Vec4Msg()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsVec4Msg(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def Vec4MsgBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x31\x30\x30", size_prefixed=size_prefixed)

    # Vec4Msg
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Vec4Msg
    def X(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Vec4Msg
    def Y(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Vec4Msg
    def Z(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Vec4Msg
    def W(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def Vec4MsgStart(builder):
    builder.StartObject(4)

def Vec4MsgAddX(builder, x):
    builder.PrependFloat32Slot(0, x, 0.0)

def Vec4MsgAddY(builder, y):
    builder.PrependFloat32Slot(1, y, 0.0)

def Vec4MsgAddZ(builder, z):
    builder.PrependFloat32Slot(2, z, 0.0)

def Vec4MsgAddW(builder, w):
    builder.PrependFloat32Slot(3, w, 0.0)

def Vec4MsgEnd(builder):
    return builder.EndObject()



class Vec4MsgT(object):

    # Vec4MsgT
    def __init__(self):
        self.x = 0.0  # type: float
        self.y = 0.0  # type: float
        self.z = 0.0  # type: float
        self.w = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        vec4Msg = Vec4Msg()
        vec4Msg.Init(buf, pos)
        return cls.InitFromObj(vec4Msg)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, vec4Msg):
        x = Vec4MsgT()
        x._UnPack(vec4Msg)
        return x

    # Vec4MsgT
    def _UnPack(self, vec4Msg):
        if vec4Msg is None:
            return
        self.x = vec4Msg.X()
        self.y = vec4Msg.Y()
        self.z = vec4Msg.Z()
        self.w = vec4Msg.W()

    # Vec4MsgT
    def Pack(self, builder):
        Vec4MsgStart(builder)
        Vec4MsgAddX(builder, self.x)
        Vec4MsgAddY(builder, self.y)
        Vec4MsgAddZ(builder, self.z)
        Vec4MsgAddW(builder, self.w)
        vec4Msg = Vec4MsgEnd(builder)
        return vec4Msg


class VRSceneObject(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = VRSceneObject()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsVRSceneObject(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def VRSceneObjectBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x31\x30\x30", size_prefixed=size_prefixed)

    # VRSceneObject
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # VRSceneObject
    def ObjectType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # VRSceneObject
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # VRSceneObject
    def Scale(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # VRSceneObject
    def Position(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Vec3Msg()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # VRSceneObject
    def Eul(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Vec3Msg()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # VRSceneObject
    def Angvel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Vec3Msg()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # VRSceneObject
    def Linvel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Vec3Msg()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def VRSceneObjectStart(builder):
    builder.StartObject(7)

def VRSceneObjectAddObjectType(builder, objectType):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(objectType), 0)

def VRSceneObjectAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def VRSceneObjectAddScale(builder, scale):
    builder.PrependFloat32Slot(2, scale, 0.0)

def VRSceneObjectAddPosition(builder, position):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(position), 0)

def VRSceneObjectAddEul(builder, eul):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(eul), 0)

def VRSceneObjectAddAngvel(builder, angvel):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(angvel), 0)

def VRSceneObjectAddLinvel(builder, linvel):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(linvel), 0)

def VRSceneObjectEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass

class VRSceneObjectT(object):

    # VRSceneObjectT
    def __init__(self):
        self.objectType = None  # type: str
        self.name = None  # type: str
        self.scale = 0.0  # type: float
        self.position = None  # type: Optional[Vec3MsgT]
        self.eul = None  # type: Optional[Vec3MsgT]
        self.angvel = None  # type: Optional[Vec3MsgT]
        self.linvel = None  # type: Optional[Vec3MsgT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        vrsceneObject = VRSceneObject()
        vrsceneObject.Init(buf, pos)
        return cls.InitFromObj(vrsceneObject)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, vrsceneObject):
        x = VRSceneObjectT()
        x._UnPack(vrsceneObject)
        return x

    # VRSceneObjectT
    def _UnPack(self, vrsceneObject):
        if vrsceneObject is None:
            return
        self.objectType = vrsceneObject.ObjectType()
        self.name = vrsceneObject.Name()
        self.scale = vrsceneObject.Scale()
        if vrsceneObject.Position() is not None:
            self.position = Vec3MsgT.InitFromObj(vrsceneObject.Position())
        if vrsceneObject.Eul() is not None:
            self.eul = Vec3MsgT.InitFromObj(vrsceneObject.Eul())
        if vrsceneObject.Angvel() is not None:
            self.angvel = Vec3MsgT.InitFromObj(vrsceneObject.Angvel())
        if vrsceneObject.Linvel() is not None:
            self.linvel = Vec3MsgT.InitFromObj(vrsceneObject.Linvel())

    # VRSceneObjectT
    def Pack(self, builder):
        if self.objectType is not None:
            objectType = builder.CreateString(self.objectType)
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.position is not None:
            position = self.position.Pack(builder)
        if self.eul is not None:
            eul = self.eul.Pack(builder)
        if self.angvel is not None:
            angvel = self.angvel.Pack(builder)
        if self.linvel is not None:
            linvel = self.linvel.Pack(builder)
        VRSceneObjectStart(builder)
        if self.objectType is not None:
            VRSceneObjectAddObjectType(builder, objectType)
        if self.name is not None:
            VRSceneObjectAddName(builder, name)
        VRSceneObjectAddScale(builder, self.scale)
        if self.position is not None:
            VRSceneObjectAddPosition(builder, position)
        if self.eul is not None:
            VRSceneObjectAddEul(builder, eul)
        if self.angvel is not None:
            VRSceneObjectAddAngvel(builder, angvel)
        if self.linvel is not None:
            VRSceneObjectAddLinvel(builder, linvel)
        vrsceneObject = VRSceneObjectEnd(builder)
        return vrsceneObject


class Quest(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Quest()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsQuest(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def QuestBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x31\x30\x30", size_prefixed=size_prefixed)

    # Quest
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Quest
    def Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # Quest
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Quest
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Quest
    def Target(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = VRSceneObject()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Quest
    def IsCompleted(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def QuestStart(builder):
    builder.StartObject(5)

def QuestAddId(builder, id):
    builder.PrependUint32Slot(0, id, 0)

def QuestAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def QuestAddType(builder, type):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)

def QuestAddTarget(builder, target):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(target), 0)

def QuestAddIsCompleted(builder, isCompleted):
    builder.PrependBoolSlot(4, isCompleted, 0)

def QuestEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass

class QuestT(object):

    # QuestT
    def __init__(self):
        self.id = 0  # type: int
        self.name = None  # type: str
        self.type = None  # type: str
        self.target = None  # type: Optional[VRSceneObjectT]
        self.isCompleted = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        quest = Quest()
        quest.Init(buf, pos)
        return cls.InitFromObj(quest)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, quest):
        x = QuestT()
        x._UnPack(quest)
        return x

    # QuestT
    def _UnPack(self, quest):
        if quest is None:
            return
        self.id = quest.Id()
        self.name = quest.Name()
        self.type = quest.Type()
        if quest.Target() is not None:
            self.target = VRSceneObjectT.InitFromObj(quest.Target())
        self.isCompleted = quest.IsCompleted()

    # QuestT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.type is not None:
            type = builder.CreateString(self.type)
        if self.target is not None:
            target = self.target.Pack(builder)
        QuestStart(builder)
        QuestAddId(builder, self.id)
        if self.name is not None:
            QuestAddName(builder, name)
        if self.type is not None:
            QuestAddType(builder, type)
        if self.target is not None:
            QuestAddTarget(builder, target)
        QuestAddIsCompleted(builder, self.isCompleted)
        quest = QuestEnd(builder)
        return quest


class MissionMsg(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MissionMsg()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMissionMsg(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def MissionMsgBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x31\x30\x30", size_prefixed=size_prefixed)

    # MissionMsg
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MissionMsg
    def Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MissionMsg
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # MissionMsg
    def Timestamp(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # MissionMsg
    def NewMission(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # MissionMsg
    def MainScene(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # MissionMsg
    def OtherScenes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # MissionMsg
    def OtherScenesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MissionMsg
    def OtherScenesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # MissionMsg
    def MainCameraPosition(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Vec3Msg()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MissionMsg
    def MainCameraEul(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Vec3Msg()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MissionMsg
    def ClearNvrObjects(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # MissionMsg
    def NvrObjects(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = VRSceneObject()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MissionMsg
    def NvrObjectsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MissionMsg
    def NvrObjectsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # MissionMsg
    def ClearVrobots(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # MissionMsg
    def Vrobots(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = VRSceneObject()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MissionMsg
    def VrobotsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MissionMsg
    def VrobotsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # MissionMsg
    def Quests(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Quest()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MissionMsg
    def QuestsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MissionMsg
    def QuestsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

def MissionMsgStart(builder):
    builder.StartObject(13)

def MissionMsgAddId(builder, id):
    builder.PrependUint32Slot(0, id, 0)

def MissionMsgAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def MissionMsgAddTimestamp(builder, timestamp):
    builder.PrependFloat64Slot(2, timestamp, 0.0)

def MissionMsgAddNewMission(builder, newMission):
    builder.PrependBoolSlot(3, newMission, 0)

def MissionMsgAddMainScene(builder, mainScene):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(mainScene), 0)

def MissionMsgAddOtherScenes(builder, otherScenes):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(otherScenes), 0)

def MissionMsgStartOtherScenesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MissionMsgAddMainCameraPosition(builder, mainCameraPosition):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(mainCameraPosition), 0)

def MissionMsgAddMainCameraEul(builder, mainCameraEul):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(mainCameraEul), 0)

def MissionMsgAddClearNvrObjects(builder, clearNvrObjects):
    builder.PrependBoolSlot(8, clearNvrObjects, 0)

def MissionMsgAddNvrObjects(builder, nvrObjects):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(nvrObjects), 0)

def MissionMsgStartNvrObjectsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MissionMsgAddClearVrobots(builder, clearVrobots):
    builder.PrependBoolSlot(10, clearVrobots, 0)

def MissionMsgAddVrobots(builder, vrobots):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(vrobots), 0)

def MissionMsgStartVrobotsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MissionMsgAddQuests(builder, quests):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(quests), 0)

def MissionMsgStartQuestsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MissionMsgEnd(builder):
    return builder.EndObject()


try:
    from typing import List, Optional
except:
    pass

class MissionMsgT(object):

    # MissionMsgT
    def __init__(self):
        self.id = 0  # type: int
        self.name = None  # type: str
        self.timestamp = 0.0  # type: float
        self.newMission = False  # type: bool
        self.mainScene = None  # type: str
        self.otherScenes = None  # type: List[str]
        self.mainCameraPosition = None  # type: Optional[Vec3MsgT]
        self.mainCameraEul = None  # type: Optional[Vec3MsgT]
        self.clearNvrObjects = False  # type: bool
        self.nvrObjects = None  # type: List[VRSceneObjectT]
        self.clearVrobots = False  # type: bool
        self.vrobots = None  # type: List[VRSceneObjectT]
        self.quests = None  # type: List[QuestT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        missionMsg = MissionMsg()
        missionMsg.Init(buf, pos)
        return cls.InitFromObj(missionMsg)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, missionMsg):
        x = MissionMsgT()
        x._UnPack(missionMsg)
        return x

    # MissionMsgT
    def _UnPack(self, missionMsg):
        if missionMsg is None:
            return
        self.id = missionMsg.Id()
        self.name = missionMsg.Name()
        self.timestamp = missionMsg.Timestamp()
        self.newMission = missionMsg.NewMission()
        self.mainScene = missionMsg.MainScene()
        if not missionMsg.OtherScenesIsNone():
            self.otherScenes = []
            for i in range(missionMsg.OtherScenesLength()):
                self.otherScenes.append(missionMsg.OtherScenes(i))
        if missionMsg.MainCameraPosition() is not None:
            self.mainCameraPosition = Vec3MsgT.InitFromObj(missionMsg.MainCameraPosition())
        if missionMsg.MainCameraEul() is not None:
            self.mainCameraEul = Vec3MsgT.InitFromObj(missionMsg.MainCameraEul())
        self.clearNvrObjects = missionMsg.ClearNvrObjects()
        if not missionMsg.NvrObjectsIsNone():
            self.nvrObjects = []
            for i in range(missionMsg.NvrObjectsLength()):
                if missionMsg.NvrObjects(i) is None:
                    self.nvrObjects.append(None)
                else:
                    vRSceneObject_ = VRSceneObjectT.InitFromObj(missionMsg.NvrObjects(i))
                    self.nvrObjects.append(vRSceneObject_)
        self.clearVrobots = missionMsg.ClearVrobots()
        if not missionMsg.VrobotsIsNone():
            self.vrobots = []
            for i in range(missionMsg.VrobotsLength()):
                if missionMsg.Vrobots(i) is None:
                    self.vrobots.append(None)
                else:
                    vRSceneObject_ = VRSceneObjectT.InitFromObj(missionMsg.Vrobots(i))
                    self.vrobots.append(vRSceneObject_)
        if not missionMsg.QuestsIsNone():
            self.quests = []
            for i in range(missionMsg.QuestsLength()):
                if missionMsg.Quests(i) is None:
                    self.quests.append(None)
                else:
                    quest_ = QuestT.InitFromObj(missionMsg.Quests(i))
                    self.quests.append(quest_)

    # MissionMsgT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.mainScene is not None:
            mainScene = builder.CreateString(self.mainScene)
        if self.otherScenes is not None:
            otherSceneslist = []
            for i in range(len(self.otherScenes)):
                otherSceneslist.append(builder.CreateString(self.otherScenes[i]))
            MissionMsgStartOtherScenesVector(builder, len(self.otherScenes))
            for i in reversed(range(len(self.otherScenes))):
                builder.PrependUOffsetTRelative(otherSceneslist[i])
            otherScenes = builder.EndVector()
        if self.mainCameraPosition is not None:
            mainCameraPosition = self.mainCameraPosition.Pack(builder)
        if self.mainCameraEul is not None:
            mainCameraEul = self.mainCameraEul.Pack(builder)
        if self.nvrObjects is not None:
            nvrObjectslist = []
            for i in range(len(self.nvrObjects)):
                nvrObjectslist.append(self.nvrObjects[i].Pack(builder))
            MissionMsgStartNvrObjectsVector(builder, len(self.nvrObjects))
            for i in reversed(range(len(self.nvrObjects))):
                builder.PrependUOffsetTRelative(nvrObjectslist[i])
            nvrObjects = builder.EndVector()
        if self.vrobots is not None:
            vrobotslist = []
            for i in range(len(self.vrobots)):
                vrobotslist.append(self.vrobots[i].Pack(builder))
            MissionMsgStartVrobotsVector(builder, len(self.vrobots))
            for i in reversed(range(len(self.vrobots))):
                builder.PrependUOffsetTRelative(vrobotslist[i])
            vrobots = builder.EndVector()
        if self.quests is not None:
            questslist = []
            for i in range(len(self.quests)):
                questslist.append(self.quests[i].Pack(builder))
            MissionMsgStartQuestsVector(builder, len(self.quests))
            for i in reversed(range(len(self.quests))):
                builder.PrependUOffsetTRelative(questslist[i])
            quests = builder.EndVector()
        MissionMsgStart(builder)
        MissionMsgAddId(builder, self.id)
        if self.name is not None:
            MissionMsgAddName(builder, name)
        MissionMsgAddTimestamp(builder, self.timestamp)
        MissionMsgAddNewMission(builder, self.newMission)
        if self.mainScene is not None:
            MissionMsgAddMainScene(builder, mainScene)
        if self.otherScenes is not None:
            MissionMsgAddOtherScenes(builder, otherScenes)
        if self.mainCameraPosition is not None:
            MissionMsgAddMainCameraPosition(builder, mainCameraPosition)
        if self.mainCameraEul is not None:
            MissionMsgAddMainCameraEul(builder, mainCameraEul)
        MissionMsgAddClearNvrObjects(builder, self.clearNvrObjects)
        if self.nvrObjects is not None:
            MissionMsgAddNvrObjects(builder, nvrObjects)
        MissionMsgAddClearVrobots(builder, self.clearVrobots)
        if self.vrobots is not None:
            MissionMsgAddVrobots(builder, vrobots)
        if self.quests is not None:
            MissionMsgAddQuests(builder, quests)
        missionMsg = MissionMsgEnd(builder)
        return missionMsg


